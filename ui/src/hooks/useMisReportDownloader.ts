import React from "react";
import * as XLSX from "xlsx";
import { useSnackbar } from "../context/SnackbarContext";
import { getCurrentUserDetails } from "../config/config";
import {
    calculateColumnWidths,
    applyThinBorders,
    extractApiPayload,
    formatDateInput,
} from "../utils/misReports";
import {
    fetchCustomerSatisfactionReport,
    fetchProblemManagementReport,
    fetchTicketResolutionTimeReport,
    fetchTicketSummaryReport,
} from "../services/ReportService";
import {
    CustomerSatisfactionReportProps,
    MISReportRequestParams,
    ProblemManagementReportProps,
    ReportPeriod,
    ReportRange,
    TicketResolutionTimeReportProps,
    TicketSummaryReportProps,
} from "../types/reports";
import { getPeriodLabel } from "../utils/reportPeriods";

export interface UseMisReportDownloaderResult {
    downloading: boolean;
    handleDownload: (option: string, period: ReportPeriod, range: ReportRange) => Promise<void>;
    handleEmail: (period: ReportPeriod, range: ReportRange) => void;
}

export const useMisReportDownloader = (
    requestParams: MISReportRequestParams,
): UseMisReportDownloaderResult => {
    const { showMessage } = useSnackbar();
    const userDetails = React.useMemo(() => getCurrentUserDetails(), []);
    const [downloading, setDownloading] = React.useState(false);

    const downloadExcel = async (period: ReportPeriod, range: ReportRange) => {
        setDownloading(true);

        try {
            const [
                ticketSummaryResponse,
                resolutionResponse,
                satisfactionResponse,
                problemResponse,
            ] = await Promise.all([
                fetchTicketSummaryReport(requestParams),
                fetchTicketResolutionTimeReport(requestParams),
                fetchCustomerSatisfactionReport(requestParams),
                fetchProblemManagementReport(requestParams),
            ]);

            const ticketSummary = extractApiPayload<TicketSummaryReportProps>(ticketSummaryResponse);
            const resolutionTime = extractApiPayload<TicketResolutionTimeReportProps>(resolutionResponse);
            const satisfaction = extractApiPayload<CustomerSatisfactionReportProps>(satisfactionResponse);
            const problemManagement = extractApiPayload<ProblemManagementReportProps>(problemResponse);

            if (!ticketSummary || !resolutionTime || !satisfaction || !problemManagement) {
                throw new Error("Incomplete data received for MIS reports.");
            }

            const downloadedBy = userDetails?.username || userDetails?.userId || "Unknown User";
            const downloadedOn = new Date();
            const fromDateLabel = requestParams.fromDate || formatDateInput(range.startDate);
            const toDateLabel = requestParams.toDate || formatDateInput(range.endDate);
            const formatDisplayDate = (value: string | Date) =>
                new Date(value).toLocaleDateString(undefined, {
                    year: "numeric",
                    month: "short",
                    day: "numeric",
                });
            const formatDisplayDateTime = (value: Date) =>
                value.toLocaleString(undefined, {
                    year: "numeric",
                    month: "short",
                    day: "numeric",
                    hour: "2-digit",
                    minute: "2-digit",
                });

            const buildHorizontalSection = (title: string, headers: (string | number)[], values: (string | number)[]) => [
                [title],
                headers,
                values,
                [],
            ];

            const buildMetadataRows = (title: string) => [
                [title],
                ["Report Generated By", downloadedBy],
                ["Generated On", formatDisplayDateTime(downloadedOn)],
                ["Date Range From", formatDisplayDate(fromDateLabel)],
                ["Date Range To", formatDisplayDate(toDateLabel)],
                [],
            ];

            const formatCategoryLabel = (item: {
                category?: string;
                subcategory?: string;
                categoryName?: string;
                subcategoryName?: string;
            }) => `${item.categoryName ?? item.category ?? "N/A"} > ${item.subcategoryName ?? item.subcategory ?? "N/A"}`;

            const summarySection = buildHorizontalSection(
                "Ticket Summary",
                [
                    "Total Tickets",
                    "Open Tickets",
                    "Closed Tickets",
                    ...Object.keys(ticketSummary.statusCounts ?? {}),
                    ...Object.keys(ticketSummary.modeCounts ?? {}),
                ],
                [
                    ticketSummary.totalTickets,
                    ticketSummary.openTickets,
                    ticketSummary.closedTickets,
                    ...Object.values(ticketSummary.statusCounts ?? {}),
                    ...Object.values(ticketSummary.modeCounts ?? {}),
                ],
            );

            const resolutionSection = (() => {
                const entries = resolutionTime.categoryStats ?? [];
                if (!entries.length) {
                    return [["Ticket Resolution Time"], ["Module", "Sub Module", "Average Time (mins)", "Median Time (mins)"], ["N/A", "N/A", "N/A", "N/A"], []];
                }

                return [
                    ["Ticket Resolution Time"],
                    ["Module", "Sub Module", "Average Time (mins)", "Median Time (mins)", "Closed Tickets"],
                    ...entries.map((entry) => [
                        entry.categoryName ?? "N/A",
                        entry.subcategoryName ?? "N/A",
                        entry.averageResolutionTime ?? "N/A",
                        entry.medianResolutionTime ?? "N/A",
                        entry.closedTickets ?? 0,
                    ]),
                    [],
                ];
            })();

            const resolutionCategorySection = (() => {
                const entries = resolutionTime.categoryPriorityStats ?? [];
                if (!entries.length) {
                    return [["Resolution Time by Category & Priority"], ["Module", "Priority", "Average Time (mins)"], ["N/A", "N/A", "N/A"], []];
                }

                return [
                    ["Resolution Time by Category & Priority"],
                    ["Module", "Priority", "Average Time (mins)", "Median Time (mins)", "Closed Tickets"],
                    ...entries.map((entry) => [
                        entry.categoryName ?? "N/A",
                        entry.priority ?? "N/A",
                        entry.averageResolutionTime ?? "N/A",
                        entry.medianResolutionTime ?? "N/A",
                        entry.closedTickets ?? 0,
                    ]),
                    [],
                ];
            })();

            const resolutionCategoryPrioritySection = (() => {
                const entries = resolutionTime.priorityStats ?? [];
                if (!entries.length) {
                    return [["Resolution Time by Priority"], ["Priority", "Average Time (mins)", "Median Time (mins)"], ["N/A", "N/A", "N/A"], []];
                }

                return [
                    ["Resolution Time by Priority"],
                    ["Priority", "Average Time (mins)", "Median Time (mins)", "Closed Tickets"],
                    ...entries.map((entry) => [
                        entry.priority ?? "N/A",
                        entry.averageResolutionTime ?? "N/A",
                        entry.medianResolutionTime ?? "N/A",
                        entry.closedTickets ?? 0,
                    ]),
                    [],
                ];
            })();

            const satisfactionSection = (() => {
                const entries = satisfaction.overallStats ?? [];
                if (!entries.length) {
                    return [["Customer Satisfaction"], ["Metric", "Value"], ["N/A", "N/A"], []];
                }

                return [
                    ["Customer Satisfaction"],
                    ["Total Responses", "Average Rating", "Positive %"],
                    [satisfaction.totalResponses ?? 0, satisfaction.averageRating ?? "N/A", satisfaction.positivePercentage ?? "N/A"],
                    [],
                ];
            })();

            const satisfactionCategorySection = (() => {
                const entries = satisfaction.categoryStats ?? [];
                if (!entries.length) {
                    return [["Customer Satisfaction by Category"], ["Module", "Sub Module", "Average Rating"], ["N/A", "N/A", "N/A"], []];
                }

                return [
                    ["Customer Satisfaction by Category"],
                    ["Module", "Sub Module", "Average Rating", "Responses"],
                    ...entries.map((entry) => [
                        entry.categoryName ?? "N/A",
                        entry.subcategoryName ?? "N/A",
                        entry.averageRating ?? "N/A",
                        entry.responses ?? 0,
                    ]),
                    [],
                ];
            })();

            const satisfactionBreakdownSection = (() => {
                const entries = satisfaction.ticketStats ?? [];
                if (!entries.length) {
                    return [["Customer Satisfaction Breakdown"], ["Ticket #", "Rating", "Feedback"], ["N/A", "N/A", "N/A"], []];
                }

                const ratingHeaders = ["1", "2", "3", "4", "5"];
                return [
                    ["Customer Satisfaction Breakdown"],
                    ["Ticket #", "Rating", "Feedback", ...ratingHeaders, "Total Responses"],
                    ...entries.map((stat) => [
                        stat.ticketNumber ?? "N/A",
                        stat.rating ?? "N/A",
                        stat.feedback ?? "-",
                        ...ratingHeaders.map((rating) => stat.ratingCounts?.[rating] ?? 0),
                        stat.totalResponses,
                    ]),
                    [],
                ];
            })();

            const problemEntries = problemManagement.categoryStats ?? [];
            const problemSection = problemEntries.length
                ? [
                    ["Problem Management"],
                    ["Module > Sub Module", "Ticket Count", "Breached Tickets"],
                    ...problemEntries.map((entry) => [
                        formatCategoryLabel(entry),
                        entry.ticketCount,
                        entry.breachedTickets ?? 0,
                    ]),
                    [],
                ]
                : [["Problem Management"], ["Module", "Ticket Count"], ["N/A", "N/A"], []];

            const workbook = XLSX.utils.book_new();

            const sheetDefinitions: { name: string; rows: (string | number)[][] }[] = [
                {
                    name: "Ticket Summary",
                    rows: [...buildMetadataRows("Ticket Summary Report"), ...summarySection],
                },
                {
                    name: "Resolution Time",
                    rows: [
                        ...buildMetadataRows("Ticket Resolution Time Report"),
                        ...resolutionSection,
                        ...resolutionCategorySection,
                        ...resolutionCategoryPrioritySection,
                    ],
                },
                {
                    name: "Customer Satisfaction",
                    rows: [
                        ...buildMetadataRows("Customer Satisfaction Report"),
                        ...satisfactionSection,
                        ...satisfactionCategorySection,
                        ...satisfactionBreakdownSection,
                    ],
                },
                {
                    name: "Problem Management",
                    rows: [...buildMetadataRows("Problem Management Report"), ...problemSection],
                },
            ];

            sheetDefinitions.forEach(({ name, rows }) => {
                const worksheet = XLSX.utils.aoa_to_sheet(rows);
                worksheet["!cols"] = calculateColumnWidths(rows);
                applyThinBorders(worksheet);
                XLSX.utils.book_append_sheet(workbook, worksheet, name);
            });

            const formattedEndDate = toDateLabel;
            const fileName = `mis-reports-${period}-${formattedEndDate}.xlsx`;
            XLSX.writeFile(workbook, fileName);
            showMessage("MIS reports downloaded successfully.", "success");
        } catch (error) {
            console.error("Failed to download MIS reports", error);
            const message = error instanceof Error ? error.message : "Failed to download MIS reports.";
            showMessage(message, "error");
        } finally {
            setDownloading(false);
        }
    };

    const handleDownload = async (option: string, period: ReportPeriod, range: ReportRange) => {
        if (option === "excel") {
            await downloadExcel(period, range);
            return;
        }

        showMessage(`${option.toUpperCase()} downloads are not available yet.`, "info");
    };

    const handleEmail = (period: ReportPeriod, range: ReportRange) => {
        const formattedRange = `${range.startDate.toLocaleDateString()} - ${range.endDate.toLocaleDateString()}`;
        showMessage(`${getPeriodLabel(period)} report for ${formattedRange} will be emailed once ready.`, "success");
    };

    return { downloading, handleDownload, handleEmail };
};
